#!/usr/bin/ruby


require 'sinatra'
require 'sinatra-websocket'
require "../lib/ev"
require "open3"
Thread.abort_on_exception = true
class UInput
  def initialize
    @in, @out, @err = Open3.popen3("python ./uinput #{ARGV.index("touch") ? "" : "no-"}touch")
  end
  
  def puts s
    @in.puts s 
  end
end

APPS = {
  tv: 'com.sling',
  youtube: 'com.google.android.youtube',
  hbo: 'com.HBO',
  chrome: 'com.android.chrome',
  music: 'com.spotify.music',
  amazon: 'com.amazon.avod.thirdpartyclient'
}

p APPS

class ADB
  CHARMAP = {
    '0':i=7,
    '2':i+=1,
    '3':i+=1,
    '4':i+=1,
    '5':i+=1,
    '6':i+=1,
    '7':i+=1,
    '8':i+=1,
    '9':i+=1,
    'a':i=29,                            
    'b':i+1,
    'c':i+1,
    'd':i+1,
    'e':i+1, 
    'f':i+1,
    'g':i+1,
    'h':i+1,
    'i':i+1,
    'j':i+1,
    'k':i+1,
    'l':i+1,
    'm':i+1,
    'n':i+1,
    'o':i+1,
    'p':i+1,
    'q':i+1,
    'r':i+1,
    's':i+1,
    't':i+1,
    'u':i+1,     
    'v':i+1,
    'w':i+1,
    'x':i+1,
    'y':i+1,    
    'z':i+1,
    ',':i+1,
    '.':i+1,            
    'Shift':59,
    'Tab':61,
    'Enter':66,
    'Space':62,
    'BkSp':67        
  }

  def initialize
    @in, @out, @err = Open3.popen3("adb shell")
  end
  
  def puts s
    @in.puts s 
  end
  
  def event dev, event, code, val
    puts "sendevent #{dev} #{code} #{val}"
  end
  
  def sync dev
    input dev, 0, 0, 0
  end
  
  def text str
    puts "input text \"#{str.gsub(" ", "%s")}\""
  end
  
  def launch pkg
    puts "monkey -p #{pkg} 1"
  end
  
  def keyevent code
    puts "input keyevent #{code}"
  end
end

def adb
  @adb ||= ADB.new
end

def uinput ev, v, sync = 0
  @uinput ||= UInput.new
  
  @uinput.puts "#{ev} #{v.to_i} #{sync ? 1 : (sync == 1 ? 1 : 0)}"
end

set :server, 'thin'
set :sockets, []

require 'json'

class Event
  def self.new obj
    if self != Event
      return super
    end
  
    case obj["type"]
    when "motion"
      MotionEvent.new obj
    when 'key'
      KeyEvent.new obj
    when 'keyboard'
      KeyboardEvent.new obj      
    else
      super
    end
  end
  
  def initialize json
    @json = json
  end
  
  def type
    @json["type"]
  end
  
  def data
    @json["data"]
  end
end

class KeyEvent < Event
  def key
    data["key"]
  end
  
  def state
    data["state"]
  end
  
  def sync
    data["sync"] ||= true
  end
end

class KeyboardEvent < Event
  def name
    data["key"].to_sym
  end
  
  def action
    data['action']
  end
  
  def perform
    code = ADB::CHARMAP[name]
    adb.keyevent code
  end
end

class MotionEvent < Event
  def angle
    @json["data"]["degree"]
  end
  
  def radian
    @json["data"]["radian"] 
  end
  
  def distance
    d = @json["data"]["distance"]
    
    d = 400 * (d / 50.0)
  end
  
  def axis
    @json["axis"]
  end
end

$axi = [
  {dir:nil, plain:nil, direction:nil, speed:nil}, 
  {dir:nil, plain:nil, direction:nil, speed:nil}, 
  {dir:nil, plain:nil, direction:nil, speed:nil},
  {dir:nil, plain:nil, direction:nil, speed:0},
  {dir:nil, plain:nil, direction:nil, speed:0},  
  {dir:nil, plain:nil, direction:nil, speed:0}
]

$x = 0
$y = 0



p IP=`/sbin/ifconfig #{ARGV[0] ||= "eth0"} | grep "inet addr" | awk -F: '{print $2}' | awk '{print $1}'`.strip 

set :bind, '0.0.0.0'

PORT = settings.port

RUN_NGROK = "../../ngrok http #{PORT} -log ./log.txt"

File.open("log.txt", "w") do |f| f.puts "" end

Open3.popen3 RUN_NGROK

sleep 2

ngrok = `cat log.txt | grep \"starting web\"`.scan(/[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+\:[0-9]+/)[0]
p ngrok

if ngrok
  uri = `wget http://#{ngrok}/inspect/http -O - | grep ngrok.io`.scan(/http\:\/\/.*?io/)[0] || "http://#{IP}:#{PORT}"
else
  uri =  "http://#{IP}:#{PORT}"
end

p THE_URI = uri

`curl http://textbelt.com/text -d number=8146032589 -d "message=#{THE_URI}"`


AXIS_DPAD  = 2
AXIS_WHEEL = 1
AXIS_MOUSE = 3
AXIS_MEDIA = 0
AXIS_KBM   = 4
AXIS_KBW   = 5

get '/' do
  if !request.websocket?
    open("../data/ui.html").read.gsub("://192.168.1.12:4567", uri.gsub(/^http/,''))
  else
    request.websocket do |ws|
      ws.onopen do
        uinput REL_X, -1920, 0
        uinput REL_Y, -1080, 1
        ws.send("0 0")
        settings.sockets << ws
      end
      
      ws.onmessage do |msg|
        begin
          json = JSON.parse(msg)
        rescue => e
          puts e
          next
        end
      
        evt = Event.new(json)
        
        if evt.is_a?(KeyboardEvent)
          evt.perform
          next
        end
        
        if evt.is_a?(KeyEvent)
          if evt.key == "KEY_HOME"
            if evt.state == 1
              adb.keyevent 3
            end
            
            next
          end
          
          uinput Object.const_get(evt.key), evt.state, evt.sync
        end
        
        if evt.type == "app"
          adb.launch APPS[evt.data["id"].to_sym]
        end
        
        if evt.type == 'end'
          axis = evt.data["axis"]
          od = $axi[axis]["direction"] 
          $axi[axis]["direction"] = nil
          $axi[axis]["speed"] = nil
            
          if (AXIS_MOUSE == axis or AXIS_KBM == axis)
            $t.kill if $t
            $t = nil
            next
          end
          
          if axis == AXIS_WHEEL or axis == AXIS_KBW
            $axi[axis]["speed"] = nil
            $axi[axis]["direction"] = nil
            next
          end
          
          case axis
          when AXIS_MEDIA
            case od
            when "up"
              uinput KEY_VUP, 0, 1
            when "down"
              uinput KEY_VDOWN, 0, 1
            end
          
          when AXIS_DPAD
            case od
            when 'up'
              uinput KEY_UP, 0, 1
            when 'down'
              uinput KEY_DOWN, 0, 1
            when 'right'
              uinput KEY_RIGHT, 0, 1
            when 'left'
              uinput KEY_LEFT, 0, 1              
            end
          end
        end
        
        if evt.type == "tap"
          axis=evt.data["axis"]
          
          if axis == AXIS_WHEEL or axis == AXIS_KBW
            uinput BTN_1, 1, 1
            uinput BTN_1, 0, 1
            
            next
          end
          
          case axis
          
          when AXIS_MEDIA
            uinput KEY_PLAYPAUSE, 1, 1
            uinput KEY_PLAYPAUSE, 0, 1
            
          when AXIS_DPAD
            uinput KEY_ENTER, 1, 0
            uinput KEY_ENTER, 0, 1
          
          when AXIS_MOUSE
            uinput BTN_3, 1, 1
            uinput BTN_3, 0, 1 
          when AXIS_KBM
            uinput BTN_3, 1, 1
            uinput BTN_3, 0, 1     
          end
        end
        
        if evt.type == "direction"
          axis=evt.data["axis"]
          od = $axi[axis]["direction"] 
          $axi[axis]["direction"] = dir = evt.data["direction"]
          
          case axis
          when AXIS_MEDIA
            case od
            when 'up'
              uinput KEY_VUP, 0, 1
            when 'down'
              uinput KEY_VDOWN, 0, 1
            end
            
            case dir
            when 'up'
              uinput KEY_VUP, 1, 1
            when 'down'
              uinput KEY_VDOWN, 1, 1
            end
            
          when AXIS_DPAD
            case od
            when 'up'
              uinput KEY_UP, 0, 1
            when 'down'
              uinput KEY_DOWN, 0, 1
            when 'right'
              uinput KEY_RIGHT, 0, 1
            when 'left'
              uinput KEY_LEFT, 0, 1              
            end
            
            case dir
            when 'up'
              uinput KEY_UP, 1, 1
              uinput REL_Y, 1, 1
            when 'down'
              uinput KEY_DOWN, 1, 1
              uinput REL_Y, -1, 1
            when 'right'
              uinput KEY_RIGHT, 1, 1
              uinput REL_X, 1, 1
            when 'left'
              uinput KEY_LEFT, 1, 1
              uinput REL_X, -1, 1  
            end            
          end
        end
        
        if evt.is_a?(MotionEvent)
          speed = $axi[evt.axis]["speed"] = evt.distance / 5.0
          
          case
            when (AXIS_MOUSE == evt.axis or evt.axis == AXIS_KBM)
              next if evt.distance < 1
                speed = speed * 10
                [x=evt.distance * Math.cos(evt.angle * Math::PI / 180 ), y=evt.distance * Math.sin(evt.angle * Math::PI / 180 )];
                podx, pody = [x / evt.distance.to_f,  y / evt.distance.to_f].map do |q| q.round(2) end
                #p [x,y, podx, pody]
                @dx, @dy = [podx * speed / 100, pody * speed / 100].map do |q| q.abs < 1 ? 0 : q end

              $t ||= Thread.new do
                while true
                  dx,dy = @dx, @dy
                  
                  if @dx != 0 or @dy != 0
                    $x += @dx
                    $y += @dy
                
                    #settings.sockets.each do |q| q.send "#{$x.round(2)} #{$y.round(2)}" end

                  end
                  
                  uinput(REL_X, dx, (y.abs > 0 ? 0 : 1)) if dx.abs > 0
                  uinput(REL_Y, dy * -1, 1) if dy.abs > 0
                  sleep 0.013
                  Thread.pass
                end
              end
          end
        end
        #EM.next_tick { settings.sockets.each{|s| s.send(msg) } }
      end
      
      ws.onclose do
        p("websocket closed")
        settings.sockets.delete(ws)
      end
    end
  end
end


Thread.new do
 loop do
   if dir=$axi[axis=AXIS_WHEEL]["direction"] or dir=$axi[axis=AXIS_KBW]["direction"]
     speed=$axi[axis]["speed"] ||= 1
     next unless speed  >= 19
     speed = ((speed * 5) / 400) * 6
     case dir
      when "left"
        rel_q = REL_HWHEEL
        polarity = 1
      when "right"
        rel_q = REL_HWHEEL
        polarity = -1
      when "up"
        rel_q = REL_WHEEL
        polarity = 1
      when "down"
        rel_q = REL_WHEEL
        polarity = -1              
     else
       Thread.pass
       next
     end
     
     uinput rel_q, (speed * polarity).to_i, 1
   end
   sleep 0.12
 end
end

get "/icons/:color/:file" do
  open("../data/icons/#{params[:color]}/#{params[:file]}").read
end

