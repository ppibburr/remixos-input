#!/usr/bin/ruby


require 'sinatra'
require 'sinatra-websocket'

require "../lib/ev"

require "open3"

Thread.abort_on_exception = true

class UInput
  def initialize
    @in, @out, @err = Open3.popen3("python ./uinput #{ARGV.index("touch") ? "" : "no-"}touch")
  end
  
  def puts s
    return unless s.split(" ").length == 3

    @in.puts s 
  end
end

APPS = {
  tv: 'com.sling',
  youtube: 'com.google.android.youtube',
  hbo: 'com.HBO',
  chrome: 'com.android.chrome',
  music: 'com.spotify.music',
  amazon: 'com.amazon.avod.thirdpartyclient'
}

class ADB
  CHARMAP = {
    '0'.to_sym => i=7,
    '1'.to_sym => i+=1,    
    '2'.to_sym => i+=1,
    '3'.to_sym => i+=1,
    '4'.to_sym => i+=1,
    '5'.to_sym => i+=1,
    '6'.to_sym => i+=1,
    '7'.to_sym => i+=1,
    '8'.to_sym => i+=1,
    '9'.to_sym => i+=1,
    'a'.to_sym => i=29,                            
    'b'.to_sym => i+=1,
    'c'.to_sym => i+=1,
    'd'.to_sym => i+=1,
    'e'.to_sym => i+=1, 
    'f'.to_sym => i+=1,
    'g'.to_sym => i+=1,
    'h'.to_sym => i+=1,
    'i'.to_sym => i+=1,
    'j'.to_sym => i+=1,
    'k'.to_sym => i+=1,
    'l'.to_sym => i+=1,
    'm'.to_sym => i+=1,
    'n'.to_sym => i+=1,
    'o'.to_sym => i+=1,
    'p'.to_sym => i+=1,
    'q'.to_sym => i+=1,
    'r'.to_sym => i+=1,
    's'.to_sym => i+=1,
    't'.to_sym => i+=1,
    'u'.to_sym => i+=1,     
    'v'.to_sym => i+=1,
    'w'.to_sym => i+=1,
    'x'.to_sym => i+=1,
    'y'.to_sym => i+=1,    
    'z'.to_sym => i+=1,
    ','.to_sym => i+=1,
    '.'.to_sym => i+=1,            
    'Shift'.to_sym => 59,
    'Tab'.to_sym => 61,
    'Enter'.to_sym => 66,
    'Space'.to_sym => 62,
    'BkSp'.to_sym => 67,
    :media_toggle  => 85,
    :home          => 3,
    :back          => 4,
    :menu          => 82,
    :search        => 84
  }

  def initialize
    @in, @out, @err = Open3.popen3("adb shell")
  end
  
  def puts s
    @in.puts s 
  end
  
  def event dev, event, code, val
    puts "sendevent #{dev} #{code} #{val}"
  end
  
  def sync dev
    input dev, 0, 0, 0
  end
  
  def text str
    puts "input text \"#{str.gsub(" ", "%s")}\""
  end
  
  def launch pkg
    play_click
    puts "monkey -p #{pkg} 1"
  end
  
  def keyevent code 
    play_click
    puts "input keyevent #{code}"
  end
  
  def tap x,y
    play_click
    puts "input tap #{x.to_i} #{y.to_i}"
  end
  
  def swipe x,y,x1,y1
    play_click
    puts "input swipe #{x.to_i} #{y.to_i} #{x1.to_i} #{y1.to_i}"
  end
  
  def active
    `adb shell dumpsys window windows | grep -E 'mCurrentFocus|mFocusedApp'`.scan(/\b[a-z]+\..*?\//)[0].gsub("/",'')
  end
  
  def search
    case active
    when "com.HBO"
      play_click
      tap 1620, 20
    when "com.amazon.avod.thirdpartyclient"
      tap 1822, 142
    else
      keyevent 84
      return
    end
    
    center_mouse
  end
end

def adb
  @adb ||= ADB.new
rescue
  @adb = nil
end

def uinput ev, v, sync = 1
  @uinput ||= UInput.new
  @uinput.puts "#{ev} #{v.to_i} #{sync}"
end

set :server, 'thin'
set :sockets, []

require 'json'

class Event
  def self.new obj
    if self != Event
      return super
    end
  
    case obj["type"]
    when "motion"
      MotionEvent.new obj
    when 'key'
      KeyEvent.new obj
    when 'keyboard'
      KeyboardEvent.new obj  
    when 'tap'
      TapEvent.new obj    
    when 'swipe'
      SwipeEvent.new obj
    else
      super
    end
  end
  
  def initialize json
    @json = json
  end
  
  def type
    @json["type"]
  end
  
  def data
    @json["data"]
  end
end

class KeyEvent < Event
  def key
    data["key"]
  end
  
  def state
    data["state"]
  end
  
  def sync
    data["sync"] ||= true
  end
end

class KeyboardEvent < Event
  EVTS = {}
  CHARMAP.each_pair do |k,v|
    EVTS[k] = true
  end
  
  
  def name
    data["key"].to_sym
  end
  
  def action
    data['action']
  end
  
  def uinput1 *o
    $ev ||= []
    
    $ev << o
    
    $ft ||= Thread.new do
      loop do
        until ev=$ev.shift
          Thread.pass
        end
        
        if ev[1] == 1
          play_click
        end
        uinput *ev
      end
    end
  end
  
  def perform
    if action == 'adb'
      code = ADB::CHARMAP[name]

      if name == :search
        adb.search
        return
      end

      adb.keyevent code
      
      return
    end
    
    case action
    when 'click'
      uinput CHARMAP[name], 1, 1
      uinput CHARMAP[name], 0, 1
    when 'down'
      uinput1 CHARMAP[name], 1, 1
    when 'up'
      uinput1 CHARMAP[name], 0, 1
    end
  end
end

class MotionEvent < Event
  def angle
    @json["data"]["degree"]
  end
  
  def radian
    @json["data"]["radian"] 
  end
  
  def distance
    d = @json["data"]["distance"]
    
    d = 400 * (d / 50.0)
  end
  
  def axis
    @json["axis"]
  end
end

class TapEvent < Event
  def x
    data['x'].to_i
  end
  
  def y
    data['y'].to_i
  end
  
  def perform
    if x and y
      adb.tap x,y
    else
      adb.tap $x,$y
    end
  end
end

class ClickEvent < Event
  def x
    data['x'].to_i
  end
  
  def y
    data['y'].to_i
  end
  
  def perform
    if x and y
      click x, y
    else
      click $x,$y
    end
  end
end

class SwipeEvent < Event
  def x
    data['x'].to_i
  end
  
  def y
    data['y'].to_i
  end
  
  def x1
    data['x1'].to_i
  end
  
  def y1
    data['y1'].to_i
  end  
  
  def amt
    data['amt'] ||= 5
  end
  
  def direction
    data['direction']
  end
  
  def perform
    if direction
      case direction
      when 'up'
        swipe_up amt
      when 'down'
        swipe_up amt
      when 'left'
        swipe_up amt
      when 'right'
        swipe_up amt
      end
      
      return
    end 
      
    swipe x,y,x1,y1
  end
end

$axi = [
  {dir:nil, plain:nil, direction:nil, speed:nil}, 
  {dir:nil, plain:nil, direction:nil, speed:nil}, 
  {dir:nil, plain:nil, direction:nil, speed:nil},
  {dir:nil, plain:nil, direction:nil, speed:0},
  {dir:nil, plain:nil, direction:nil, speed:0},  
  {dir:nil, plain:nil, direction:nil, speed:0}
]

$x = 0
$y = 0



IP=`/sbin/ifconfig #{ARGV[0] ||= "eth0"} | grep "inet addr" | awk -F: '{print $2}' | awk '{print $1}'`.strip 

set :bind, '0.0.0.0'

PORT = settings.port

RUN_NGROK = "../../ngrok http #{PORT} -log ./log.txt"

File.open("log.txt", "w") do |f| f.puts "" end

Open3.popen3 RUN_NGROK

sleep 2

ngrok = `cat log.txt | grep \"starting web\"`.scan(/[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+\:[0-9]+/)[0]

if ngrok
  uri = `wget http://#{ngrok}/inspect/http -O - &2>/dev/null | grep ngrok.io`.scan(/http\:\/\/.*?io/)[0] || "http://#{IP}:#{PORT}"
else
  uri =  "http://#{IP}:#{PORT}"
end

puts "\n\n\n"*5

puts "Using IP: #{ IP}"
puts "Using IP: #{ PORT}"
puts "ngrok data @ #{ngrok}"
puts "RUN!!\nConnect to: #{THE_URI = uri}"


IO.popen("curl http://textbelt.com/text -d number=8146032589 -d \"message=#{THE_URI}\"")


AXIS_DPAD  = 2
AXIS_WHEEL = 1
AXIS_MOUSE = 3
AXIS_MEDIA = 0
AXIS_KBM   = 4
AXIS_KBW   = 5

get '/' do
  if !request.websocket?
    open("../data/ui.html").read.gsub("://192.168.1.12:4567", uri.gsub(/^http/,''))
  else
    request.websocket do |ws|
      ws.onopen do
        
        init_mouse_coords
        
        ws.send("0 0")
    
        settings.sockets << ws
      end
      
      ws.onmessage do |msg|
        begin
          json = JSON.parse(msg)
        rescue => e
          puts e
          next
        end
      
        evt = Event.new(json)
        
        if evt.is_a?(KeyboardEvent)
          evt.perform
          next
        end
        
        if evt.is_a?(KeyEvent)
          if evt.key == "KEY_HOME"
            if evt.state == 1
              adb.keyevent 3
            end
            
            next
          end
          
          uinput Object.const_get(evt.key), evt.state, evt.sync
        end
        
        if evt.type == "app"
          adb.launch APPS[evt.data["id"].to_sym] if evt.data["id"]
        end
        
        if evt.type == 'end'
          axis = evt.data["axis"]
          od = $axi[axis]["direction"] 
          $axi[axis]["direction"] = nil
          $axi[axis]["speed"] = nil
            
          if (AXIS_MOUSE == axis or AXIS_KBM == axis)
            $t.kill if $t
            $t = nil
            next
          end
          
          if axis == AXIS_WHEEL or axis == AXIS_KBW
            $axi[axis]["speed"] = nil
            $axi[axis]["direction"] = nil
            next
          end
          
          case axis
          when AXIS_MEDIA
            case od
            when 'up'
              release KEY_VUP
            when 'down'
              release KEY_VDOWN
            end
          
          when AXIS_DPAD
            case od
            when 'up'
              release KEY_UP
            when 'down'
              release KEY_DOWN
            when 'right'
              release KEY_RIGHT
            when 'left'
              release KEY_LEFT             
            end
          end
        end
        
        if evt.type == "tap"
          axis=evt.data["axis"]
          
          if axis == AXIS_WHEEL or axis == AXIS_KBW
            click BTN_1
            
            next
          end
          
          case axis
          
          when AXIS_MEDIA
            click KEY_PLAYPAUSE
          when AXIS_DPAD
            click KEY_ENTER
          when AXIS_MOUSE
            click BTN_3
          when AXIS_KBM
            click BTN_3  
          end
        end
        
        if evt.type == "direction"
          axis=evt.data["axis"]
          od = $axi[axis]["direction"] 
          $axi[axis]["direction"] = dir = evt.data["direction"]
          
          case axis
          when AXIS_MEDIA
            case od
            when 'up'
              release KEY_VUP
            when 'down'
              release KEY_VDOWN
            end
            
            case dir
            when 'up'
              press KEY_VUP
            when 'down'
              press KEY_VDOWN
            end
            
          when AXIS_DPAD
            case od
            when 'up'
              release KEY_UP
            when 'down'
              release KEY_DOWN
            when 'right'
              release KEY_RIGHT
            when 'left'
              release KEY_LEFT             
            end
            
            case dir
            when 'up'

              press KEY_UP
              uinput REL_Y, 1, 1
            when 'down'

              press KEY_DOWN
              uinput REL_Y, -1, 1
            when 'right'

              press KEY_RIGHT
              uinput REL_X, 1, 1
            when 'left'

              press KEY_LEFT
              uinput REL_X, -1, 1  
            end            
          end
        end
        
        if evt.is_a?(MotionEvent)
          speed = $axi[evt.axis]["speed"] = evt.distance / 5.0
          
          case
            when (AXIS_MOUSE == evt.axis or evt.axis == AXIS_KBM)
              next if evt.distance < 1
                speed = speed * 10
                [x=evt.distance * Math.cos(evt.angle * Math::PI / 180 ), y=evt.distance * Math.sin(evt.angle * Math::PI / 180 )];
                podx, pody = [x / evt.distance.to_f,  y / evt.distance.to_f].map do |q| q.round(2) end
                #p [x,y, podx, pody]
                @dx, @dy = [podx * speed / 100, pody * speed / 100].map do |q| q.abs < 1 ? 0 : q end

              $t ||= Thread.new do
                while true
                  dx,dy = @dx, @dy
                  
                  rel_move_mouse(dx,dy)
                  
                  sleep 0.013
                  Thread.pass
                end
              end
          end
        end
        #EM.next_tick { settings.sockets.each{|s| s.send(msg) } }
      end
      
      ws.onclose do
        p("websocket closed")
        settings.sockets.delete(ws)
      end
    end
  end
end


def play_click
  Thread.new do
    system("aplay ../data/click.wav") || system("aplay -D hw:1,0 ../data/click.wav") || system("aplay -D hw:0,3 ../data/click.wav")  || system("beep -l 2")
  end
end

def center_mouse
  abs_move_mouse $x=(SCREEN[:width]/2.0).to_i, $y=(SCREEN[:height]/2.0).to_i
end

def click ev, x=nil, y=nil
  if x or y
    abs_move_mouse(x,y)
  end

  press
  release
end

def press ev, x=nil, y=nil
  if x or y
    abs_move_mouse(x,y)
  end

  play_click

  uinput ev,1,1
end

def release ev, x=nil, y=nil
  if x or y
    abs_move_mouse(x,y)
  end

  uinput ev,0,1
end


def swipe x,y,x1,y1
  adb.swipe x,y,x1,y1
end

def swipe_up amt=5, x = $x, y = $y
  swipe x,y,x+amt,y
end

def swipe_right amt=5, x = $x, y = $y
  swipe x,y,x+amt,y
end

def swipe_left amt=5, x = $x, y = $y
  swipe x,y,x-amt,y
end


def swipe_up amt=5, x = $x, y = $y
  swipe x,y,x,y-amt
end


def swipe_up amt=5, x = $x, y = $y
  swipe x,y,x,y+amt
end

# abs start / finish
def drag_abs x,y,x1,y1,step = 0
  abs_move_mouse(x,y)
  
  press BTN_1
  
  rel_move_mouse(x1-x,y1-y)
  
  $x, $y = x1,y1

  release BTN_1
end

# rel start of 0, rel finish
def drag x,y, step = 0
  press BTN_1
  
  rel_move_mouse(x1-x,y1-y)
  
  $x += x
  $y += y
  
  release BTN_1
end

### Relative drags
def drag_up amt=5, step=0
  drag 0, amt, step
end

def drag_down amt=5, step=0
  drag 0, -1*amt, step
end

def drag_left amt=5, step=0
  drag -1*amt, 0, step
end

def drag_right amt=5, step=0
  drag amt, 0, step
end
###


def init_mouse_coords
  uinput REL_X, -1*SCREEN[:width], 1
  uinput REL_Y, -1*SCREEN[:height], 1
end

def abs_move_mouse x,y
  init_mouse_coords
  
  sleep 0.1
    
  x ||= 0
  y ||= 0
  
  rel_move_mouse x,y
end


def rel_move_mouse x,y
  if x != 0 or y != 0
	$x += x
	$y += y
	
	$x = SCREEN[:width] if $x > SCREEN[:width]
	$y = SCREEN[:height] if $y > SCREEN[:height]
	
	$x = 0 if $x < 0
	$y = 0 if $y < 0
	
   
	settings.sockets.each do |q| q.send "#{$x.round(2)} #{$y.round(2)}" end

  end
  
  uinput(REL_X, x, ( 1)) if x.abs > 0
  uinput(REL_Y, y * -1, 1) if y.abs > 0
end

Thread.new do
 loop do
   if dir=$axi[axis=AXIS_WHEEL]["direction"] or dir=$axi[axis=AXIS_KBW]["direction"]
     speed=$axi[axis]["speed"] ||= 1
     next unless speed  >= 19
     speed = ((speed * 5) / 400) * 6
     case dir
      when "left"
        rel_q = REL_HWHEEL
        polarity = 1
      when "right"
        rel_q = REL_HWHEEL
        polarity = -1
      when "up"
        rel_q = REL_WHEEL
        polarity = 1
      when "down"
        rel_q = REL_WHEEL
        polarity = -1              
     else
       Thread.pass
       next
     end
     
     play_click
     
     uinput rel_q, (speed * polarity).to_i, 1
   end
   sleep 0.12
 end
end

get "/icons/:color/:file" do
  open("../data/icons/#{params[:color]}/#{params[:file]}").read
end

