#!/usr/bin/ruby


require 'sinatra'
require 'sinatra-websocket'
require "../lib/ev"
require "open3"
Thread.abort_on_exception = true
class UInput
  def initialize
    @in, @out, @err = Open3.popen3("python ./uinput")
  end
  
  def puts s
    @in.puts s 
  end
end

class ADB
  def initialize
    @in, @out, @err = Open3.popen3("adb shell")
  end
  
  def puts s
    @in.puts s 
  end
  
  def event dev, event, code, val
    puts "sendevent #{dev} #{code} #{val}"
  end
  
  def sync dev
    input dev, 0, 0, 0
  end
  
  def text str
    puts "input text \"#{str.gsub(" ", "%s")}\""
  end
  
  def launch pkg
    puts "monkey -p #{pkg} 1"
  end
  
  def keyevent code
    puts "input keyevent #{code}"
  end
end

def adb
  @adb ||= ADB.new
end

def uinput ev, v, sync = 0
  @uinput ||= UInput.new
  
  @uinput.puts "#{ev} #{v.to_i} #{sync ? 1 : (sync == 1 ? 1 : 0)}"
end

set :server, 'thin'
set :sockets, []

require 'json'

class Event
  def self.new obj
    if self != Event
      return super
    end
  
    case obj["type"]
    when "motion"
      MotionEvent.new obj
    else
      super
    end
  end
  
  def initialize json
    @json = json
  end
  
  def type
    @json["type"]
  end
  
  def data
    @json["data"]
  end
end

class MotionEvent < Event
  def angle
    @json["data"]["degree"]
  end
  
  def radian
    @json["data"]["radian"] 
  end
  
  def distance
    d = @json["data"]["distance"]
    
    d = 400 * (d / 50.0)
  end
  
  def axis
    @json["axis"]
  end
end

$axi = [
  {dir:nil, plain:nil, direction:nil, speed:nil}, 
  {dir:nil, plain:nil, direction:nil, speed:nil}, 
  {dir:nil, plain:nil, direction:nil, speed:nil},
  {dir:nil, plain:nil, direction:nil, speed:0}
]

$x = 0
$y = 0



get '/' do
  if !request.websocket?
    open("../data/ui.html").read
  else
    request.websocket do |ws|
      ws.onopen do
        uinput REL_X, -1920, 0
        uinput REL_Y, -1080, 1
        ws.send("0 0")
        settings.sockets << ws
      end
      
      ws.onmessage do |msg|
        begin
          json = JSON.parse(msg)
        rescue => e
          puts e
          next
        end
      
        evt = Event.new(json)
        
        if evt.type == 'end'
          axis = evt.data["axis"]
          od = $axi[axis]["direction"] 
          $axi[axis]["direction"] = nil
          $axi[axis]["speed"] = nil
            
          case axis
          when 1
            $t.kill
            $t = nil
          when 3
            $axi[3]["speed"] = nil
            $axi[3]["direction"] = nil
          when 0
            case od
            when "up"
              uinput KEY_VUP, 0, 1
            when "down"
              uinput KEY_VDOWN, 0, 1
            end
          
          when 2
            case od
            when 'up'
              uinput KEY_UP, 0, 1
            when 'down'
              uinput KEY_DOWN, 0, 1
            when 'right'
              uinput KEY_RIGHT, 0, 1
            when 'left'
              uinput KEY_LEFT, 0, 1              
            end
          end
        end
        
        if evt.type == "tap"
          case evt.data["axis"]
          when 3
            uinput BTN_1, 1, 0
            uinput BTN_1, 0, 1
          
          when 0
            uinput KEY_PLAYPAUSE, 1, 0
            uinput KEY_PLAYPAUSE, 0, 1
            
          when 2
            uinput KEY_ENTER, 1, 0
            uinput KEY_ENTER, 0, 1
          
          when 1
            uinput BTN_3, 1, 0
            uinput BTN_3, 0, 1    
          end
        end
        
        if evt.type == "direction"
          axis=evt.data["axis"]
          od = $axi[axis]["direction"] 
          $axi[axis]["direction"] = dir = evt.data["direction"]
          
          case axis
          when 0
            case od
            when 'up'
              uinput KEY_VUP, 0, 1
            when 'down'
              uinput KEY_VDOWN, 0, 1
            end
            
            case dir
            when 'up'
              uinput KEY_VUP, 1, 1
            when 'down'
              uinput KEY_VDOWN, 1, 1
            end
            
          when 2
            case od
            when 'up'
              uinput KEY_UP, 0, 1
            when 'down'
              uinput KEY_DOWN, 0, 1
            when 'right'
              uinput KEY_RIGHT, 0, 1
            when 'left'
              uinput KEY_LEFT, 0, 1              
            end
            
            case dir
            when 'up'
              uinput KEY_UP, 1, 1
            when 'down'
              uinput KEY_DOWN, 1, 1
            when 'right'
              uinput KEY_RIGHT, 1, 1
            when 'left'
              uinput KEY_LEFT, 1, 1  
            end            
          end
        end
        
        if evt.is_a?(MotionEvent)
          speed = $axi[evt.axis]["speed"] = evt.distance / 5.0
          
          case evt.axis
            when 1  
              next if evt.distance < 10
              
                [x=evt.distance * Math.cos(evt.angle * Math::PI / 180 ), y=evt.distance * Math.sin(evt.angle * Math::PI / 180 )];
                podx, pody = [x / evt.distance.to_f,  y / evt.distance.to_f].map do |q| q.round(2) end
                #p [x,y, podx, pody]
                @dx, @dy = [podx * speed, pody * speed].map do |q| q.abs < 1 ? 0 : q end
                #p [:move, dx, dy]
              $t ||= Thread.new do
                while true
                  dx,dy = @dx, @dy
                  
                  if @dx != 0 or @dy != 0
                    $x += @dx
                    $y += @dy
                
                    settings.sockets.each do |q| q.send "#{$x.round(2)} #{$y.round(2)}" end

                  end
                  
                  uinput(REL_X, dx, (y.abs > 0 ? 0 : 1)) if dx.abs > 0
                  uinput(REL_Y, dy * -1, 1) if dy.abs > 0
                  sleep 0.0255
                end
              end
          end
        end
        #EM.next_tick { settings.sockets.each{|s| s.send(msg) } }
      end
      
      ws.onclose do
        p("websocket closed")
        settings.sockets.delete(ws)
      end
    end
  end
end


Thread.new do
 loop do
   if dir=$axi[3]["direction"]
     speed=$axi[3]["speed"] ||= 1
     next unless $axi[3]["speed"] >= 19
     case dir
      when "left"
        rel_q = REL_HWHEEL
        polarity = 1
      when "right"
        rel_q = REL_HWHEEL
        polarity = -1
      when "up"
        rel_q = REL_WHEEL
        polarity = 1
      when "down"
        rel_q = REL_WHEEL
        polarity = -1              
     else
       Thread.pass
       next
     end
     
     uinput rel_q, (speed * polarity).to_i, 1
   end
   sleep 0.12
 end
end

get "/icons/:color/:file" do
  open("../data/icons/#{params[:color]}/#{params[:file]}").read
end

