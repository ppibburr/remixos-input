#!/usr/bin/ruby


require 'sinatra'
require 'sinatra-websocket'

require "../lib/ev"

require "open3"

Thread.abort_on_exception = true

SCREEN = {
  :width => 1920,
  :height => 1080
}

class UInput
  def initialize
    @in, @out, @err = Open3.popen3("python ./uinput #{ARGV.index("touch") ? "" : "no-"}touch")
  end
  
  def puts s
    return unless s.split(" ").length == 3

    @in.puts s 
  end
end

APPS = {
  tv: 'com.sling',
  youtube: 'com.google.android.youtube',
  hbo: 'com.HBO',
  chrome: 'com.android.chrome',
  music: 'com.spotify.music',
  amazon: 'com.amazon.avod.thirdpartyclient',
  settings: 'com.android.settings'
}

class ADB
  CHARMAP = {
    '0'.to_sym => i=7,
    '1'.to_sym => i+=1,    
    '2'.to_sym => i+=1,
    '3'.to_sym => i+=1,
    '4'.to_sym => i+=1,
    '5'.to_sym => i+=1,
    '6'.to_sym => i+=1,
    '7'.to_sym => i+=1,
    '8'.to_sym => i+=1,
    '9'.to_sym => i+=1,
    'a'.to_sym => i=29,                            
    'b'.to_sym => i+=1,
    'c'.to_sym => i+=1,
    'd'.to_sym => i+=1,
    'e'.to_sym => i+=1, 
    'f'.to_sym => i+=1,
    'g'.to_sym => i+=1,
    'h'.to_sym => i+=1,
    'i'.to_sym => i+=1,
    'j'.to_sym => i+=1,
    'k'.to_sym => i+=1,
    'l'.to_sym => i+=1,
    'm'.to_sym => i+=1,
    'n'.to_sym => i+=1,
    'o'.to_sym => i+=1,
    'p'.to_sym => i+=1,
    'q'.to_sym => i+=1,
    'r'.to_sym => i+=1,
    's'.to_sym => i+=1,
    't'.to_sym => i+=1,
    'u'.to_sym => i+=1,     
    'v'.to_sym => i+=1,
    'w'.to_sym => i+=1,
    'x'.to_sym => i+=1,
    'y'.to_sym => i+=1,    
    'z'.to_sym => i+=1,
    ','.to_sym => i+=1,
    '.'.to_sym => i+=1,            
    'Shift'.to_sym => 59,
    'Tab'.to_sym => 61,
    'Enter'.to_sym => 66,
    'Space'.to_sym => 62,
    'BkSp'.to_sym => 67,
    :media_toggle  => 85,
    :home          => 3,
    :back          => 4,
    :menu          => 82,
    :search        => 84
  }

  def initialize
    @in, @out, @err = Open3.popen3("adb shell")
  end
  
  def puts s
    @in.puts s 
  end
  
  def event dev, event, code, val
    puts "sendevent #{dev} #{code} #{val}"
  end
  
  def sync dev
    input dev, 0, 0, 0
  end
  
  def text str
    puts "input text \"#{str.gsub(" ", "%s")}\""
  end
  
  def launch pkg
    play_click
    puts "monkey -p #{pkg} 1"
  end
  
  def keyevent code 
    play_click
    puts "input keyevent #{code}"
  end
  
  def tap x,y
    play_click
    puts "input tap #{x.to_i} #{y.to_i}"
  end
  
  def swipe x,y,x1,y1
    play_click
    puts "input swipe #{x.to_i} #{y.to_i} #{x1.to_i} #{y1.to_i}"
  end
  
  def active
    `adb shell dumpsys window windows | grep -E 'mCurrentFocus|mFocusedApp'`.scan(/\b[a-z]+\..*?\//)[0].gsub("/",'')
  end
  
  def search
    case active
    when "com.HBO"
      tap 1620, 20
    when "com.amazon.avod.thirdpartyclient"
      tap 1830, 90
    else
      keyevent 84
    end
    
    center_mouse
  end
  
  def app_menu
    case active
    when "com.HBO"
      tap 26,60
    when "com.amazon.avod.thirdpartyclient"
      tap 26,60
    else
      tap 26,60
    end
    
    abs_move_mouse(80,100)
  end   
end

def adb
  @adb ||= ADB.new
rescue
  @adb = nil
end

def uinput ev, v, sync = 1
  @uinput ||= UInput.new
  @uinput.puts "#{ev} #{v.to_i} #{sync}"
end

set :server, 'thin'
set :sockets, []

require 'json'

class Event
  def self.new obj
    if self != Event
      return super
    end
  
    case obj["type"]
    when "motion"
      MotionEvent.new obj
    when 'key'
      KeyEvent.new obj
    when 'keyboard'
      KeyboardEvent.new obj  
    when 'tap'
      TapEvent.new obj    
    when 'swipe'
      SwipeEvent.new obj
    when 'shell'
      ShellEvent.new obj
    else
      super
    end
  end
  
  def initialize json
    @json = json
  end
  
  def type
    @json["type"]
  end
  
  def data
    @json["data"]
  end
end

class KeyEvent < Event
  def key
    data["key"]
  end
  
  def state
    data["state"]
  end
  
  def sync
    data["sync"] ||= true
  end
end

class KeyboardEvent < Event
  EVTS = {}
  CHARMAP.each_pair do |k,v|
    EVTS[k] = true
  end
  
  
  def name
    data["key"].to_sym
  end
  
  def action
    data['action']
  end
  
  def uinput1 *o
    $ev ||= []
    
    $ev << o
    
    $ft ||= Thread.new do
      loop do
        until ev=$ev.shift
          Thread.pass
        end
        
        if ev[1] == 1
          play_click
        end
        uinput *ev
      end
    end
  end
  
  def perform
    if action == 'adb'
      code = ADB::CHARMAP[name]

      if name == :search
        adb.search
        return
      end

      adb.keyevent code
      
      return
    end
    
    case action
    when 'click'
      uinput CHARMAP[name], 1, 1
      uinput CHARMAP[name], 0, 1
    when 'down'
      uinput1 CHARMAP[name], 1, 1
    when 'up'
      uinput1 CHARMAP[name], 0, 1
    end
  end
end

class MotionEvent < Event
  def angle
    @json["data"]["degree"]
  end
  
  def radian
    @json["data"]["radian"] 
  end
  
  def distance
    d = @json["data"]["distance"]
    
    d = 400 * (d / 50.0)
  end
  
  def axis
    @json["axis"]
  end
end

class TapEvent < Event
  def x
    data['x'].to_i
  end
  
  def y
    data['y'].to_i
  end
  
  def perform
    if x and y
      adb.tap x,y
    else
      adb.tap $x,$y
    end
  end
end

class ClickEvent < Event
  def x
    data['x'].to_i
  end
  
  def y
    data['y'].to_i
  end
  
  def perform
    if x and y
      click x, y
    else
      click
    end
  end
end

class SwipeEvent < Event
  def x
    data['x'].to_i
  end
  
  def y
    data['y'].to_i
  end
  
  def x1
    data['x1'].to_i
  end
  
  def y1
    data['y1'].to_i
  end  
  
  def amt
    data['amt'] ||= 5
  end
  
  def direction
    data['direction']
  end
  
  def perform
    if direction
      case direction
      when 'up'
        swipe_up amt
      when 'down'
        swipe_up amt
      when 'left'
        swipe_up amt
      when 'right'
        swipe_up amt
      end
      
      return
    end 
      
    swipe x,y,x1,y1
  end
end

class ShellEvent < Event
  def action
    data['action']
  end


  def perform s
    case action
    when 'feed'
      Shell.instances[s].feed data['body']
    when 'term'
      Shell.instances[s].terminate
    end
  end
end

$axi = [
  {dir:nil, plain:nil, direction:nil, speed:nil}, 
  {dir:nil, plain:nil, direction:nil, speed:nil}, 
  {dir:nil, plain:nil, direction:nil, speed:nil},
  {dir:nil, plain:nil, direction:nil, speed:0},
  {dir:nil, plain:nil, direction:nil, speed:0},  
  {dir:nil, plain:nil, direction:nil, speed:0}
]

$x = 0
$y = 0



IP=`/sbin/ifconfig #{ARGV[0] ||= "eth0"} | grep "inet addr" | awk -F: '{print $2}' | awk '{print $1}'`.strip 

set :bind, '0.0.0.0'
$settings = settings
PORT = settings.port

RUN_NGROK = "../../ngrok http #{PORT} -log ./log.txt"

if !File.exist?("./log.txt")
  File.open("log.txt", "w") do |f| f.puts "" end
  system "ruby -ropen3 -e \"fork do;"+
    "Process.daemon(true);"+
    "i,oe,t = Open3.popen2e '#{RUN_NGROK}';"+
    "t.join;"+
  "end;\""
  sleep 2
end

ngrok = `cat log.txt | grep \"starting web\"`.scan(/[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+\:[0-9]+/)[0]

if ngrok
  uri = `wget http://#{ngrok}/inspect/http -O - &2>/dev/null | grep ngrok.io`.scan(/http\:\/\/.*?io/)[0] || "http://#{IP}:#{PORT}"
else
  uri =  "http://#{IP}:#{PORT}"
end

puts "\n\n\n"*5
puts "Using IP: #{ IP}"
puts "Using IP: #{ PORT}"
puts "ngrok data @ #{ngrok}"
puts "RUN!!\nConnect to: #{THE_URI = uri}"

IO.popen("curl http://textbelt.com/text -d number=8146032589 -d \"message=#{THE_URI}\"")

AXIS_DPAD  = 2
AXIS_WHEEL = 1
AXIS_MOUSE = 3
AXIS_MEDIA = 0
AXIS_KBM   = 4
AXIS_KBW   = 5

def update
  fork do
    Dir.chdir "../"
    system "git pull origin master"
    Dir.chdir "./scripts"
    system "bash ./start.sh"
  end
end


def play_click
  Thread.new do
    #system("aplay ../data/click.wav") == 1 || system("aplay -D hw:0,3 ../data/click.wav") == 1 || system("aplay -D hw:1,0 ../data/click.wav") == 1  || nil
    system("beep -l 2")
  end
end

def center_mouse
  abs_move_mouse (SCREEN[:width]/2.0).to_i, (SCREEN[:height]/2.0).to_i
end

def click ev, x=nil, y=nil
  if x or y
    abs_move_mouse(x,y)
  end

  press ev
  release ev
end

def press ev, x=nil, y=nil
  if x or y
    abs_move_mouse(x,y)
  end

  play_click

  uinput ev,1,1
end

def release ev, x=nil, y=nil
  if x or y
    abs_move_mouse(x,y)
  end

  uinput ev,0,1
end


def swipe x,y,x1,y1
  adb.swipe x,y,x1,y1
end

def swipe_up amt=5, x = $x, y = $y
  swipe x,y,x+amt,y
end

def swipe_right amt=5, x = $x, y = $y
  swipe x,y,x+amt,y
end

def swipe_left amt=5, x = $x, y = $y
  swipe x,y,x-amt,y
end


def swipe_up amt=5, x = $x, y = $y
  swipe x,y,x,y-amt
end


def swipe_up amt=5, x = $x, y = $y
  swipe x,y,x,y+amt
end

# abs start / finish
def drag_abs x,y,x1,y1,step = 0
  abs_move_mouse(x,y)
  
  press BTN_1
  
  rel_move_mouse(x1-x,y1-y)
  
  $x, $y = x1,y1

  release BTN_1
end

# rel start of 0, rel finish
def drag x,y, step = 0
  press BTN_1
  
  rel_move_mouse(x1-x,y1-y)
  
  $x += x
  $y += y
  
  release BTN_1
end

### Relative drags
def drag_up amt=5, step=0
  drag 0, amt, step
end

def drag_down amt=5, step=0
  drag 0, -1*amt, step
end

def drag_left amt=5, step=0
  drag -1*amt, 0, step
end

def drag_right amt=5, step=0
  drag amt, 0, step
end
###


def init_mouse_coords
  sx = SCREEN[:width]
  sy = SCREEN[:height]
  
 # sx.times do
    uinput REL_X, -1*sx, 1
 # end
  
 # sy.times do
    uinput REL_Y, -1*sy, 1
 # end
  
  $x,$y=0,0  
end

def abs_move_mouse x,y
  init_mouse_coords
  
  sleep 0.1
    
  x ||= 0
  y ||= 0
  
  rel_move_mouse x,-1*y
end


def rel_move_mouse x,y
  if x != 0 or y != 0
    $x += x
    $y += y*-1
    
    $x = SCREEN[:width] if $x > SCREEN[:width]
    $y = SCREEN[:height] if $y > SCREEN[:height]
    
    $x = 0 if $x < 0
    $y = 0 if $y < 0
    
    ux, uy = $x.round(2), $y.round(2) 
    
    $settings.sockets.each do |q| q.send("{type: 'coords', data: {x: #{ux}, y: #{uy}}}")  end

  end
  
  uinput(REL_X, x, ( 0)) # if x.abs > 0
  uinput(REL_Y, -1*y, 1) # if y.abs > 0
end

begin

get '/' do
  if !request.websocket?
    open("../data/ui.html").read.gsub("://192.168.1.12:4567", uri.gsub(/^http/,''))
  else
    request.websocket do |ws|
      ws.onopen do
        Shell.new(ws)
        
        
        center_mouse
    
        settings.sockets << ws
        
        30.times do
          play_click
        end
      end
      
      ws.onmessage do |msg|
        begin
          json = JSON.parse(msg)
        rescue => e
          puts e
          next
        end
      
        evt = Event.new(json)
        
        if evt.is_a?(KeyboardEvent)
          evt.perform
          next
        end
        
        if evt.is_a?(KeyEvent)
          if evt.key == "KEY_HOME"
            if evt.state == 1
              adb.keyevent 3
            end
            
            next
          end
          
          uinput Object.const_get(evt.key), evt.state, evt.sync
        end
        
        if evt.is_a?(ShellEvent)
          evt.perform(ws)
          next
        end
        
        if evt.type == "center"
          center_mouse()
        end
        
        if evt.type == "app"
          next if !evt.data["id"]
          
          if evt.data["id"] == "app_menu"
            adb.app_menu
            next
          else
            adb.launch APPS[evt.data["id"].to_sym] if evt.data["id"]
          end
          
          center_mouse
        end
        
        if evt.type == 'end'
          axis = evt.data["axis"]
          od = $axi[axis]["direction"] 
          $axi[axis]["direction"] = nil
          $axi[axis]["speed"] = nil
            
          if (AXIS_MOUSE == axis or AXIS_KBM == axis)
            $t.kill if $t
            $t = nil
            next
          end
          
          if axis == AXIS_WHEEL or axis == AXIS_KBW
            $axi[axis]["speed"] = nil
            $axi[axis]["direction"] = nil
            next
          end
          
          case axis
          when AXIS_MEDIA
            case od
            when 'up'
              release KEY_VUP
            when 'down'
              release KEY_VDOWN
            end
          
          when AXIS_DPAD
            case od
            when 'up'
              release KEY_UP
            when 'down'
              release KEY_DOWN
            when 'right'
              release KEY_RIGHT
            when 'left'
              release KEY_LEFT             
            end
          end
        end
        
        if evt.type == "tap"
          axis=evt.data["axis"]
          
          if axis == AXIS_WHEEL or axis == AXIS_KBW
            click BTN_1
            
            next
          end
          
          case axis
          
          when AXIS_MEDIA
            click KEY_PLAYPAUSE
          when AXIS_DPAD
            click KEY_ENTER
          when AXIS_MOUSE
            click BTN_3
          when AXIS_KBM
            click BTN_3  
          end
        end
        
        if evt.type == "direction"
          axis=evt.data["axis"]
          od = $axi[axis]["direction"] 
          $axi[axis]["direction"] = dir = evt.data["direction"]
          
          case axis
          when AXIS_MEDIA
            case od
            when 'up'
              release KEY_VUP
            when 'down'
              release KEY_VDOWN
            end
            
            case dir
            when 'up'
              press KEY_VUP
            when 'down'
              press KEY_VDOWN
            end
            
          when AXIS_DPAD
            case od
            when 'up'
              release KEY_UP
            when 'down'
              release KEY_DOWN
            when 'right'
              release KEY_RIGHT
            when 'left'
              release KEY_LEFT             
            end
            
            case dir
            when 'up'

              press KEY_UP
              uinput REL_Y, 1, 1
            when 'down'

              press KEY_DOWN
              uinput REL_Y, -1, 1
            when 'right'

              press KEY_RIGHT
              uinput REL_X, 1, 1
            when 'left'

              press KEY_LEFT
              uinput REL_X, -1, 1  
            end            
          end
        end
        
        if evt.type == 'update'
          update()
        end
        
        if evt.is_a?(MotionEvent)
          speed = $axi[evt.axis]["speed"] = evt.distance / 5.0
          
          case
            when (AXIS_MOUSE == evt.axis or evt.axis == AXIS_KBM)
              next if evt.distance < 1
                speed = speed * 10
                [x=evt.distance * Math.cos(evt.angle * Math::PI / 180 ), y=evt.distance * Math.sin(evt.angle * Math::PI / 180 )];
                podx, pody = [x / evt.distance.to_f,  y / evt.distance.to_f].map do |q| q.round(2) end
                #p [x,y, podx, pody]
                @dx, @dy = [podx * speed / 100, pody * speed / 100].map do |q| q.abs < 1 ? 0 : q end

              $t ||= Thread.new do
                while true
                  dx,dy = @dx, @dy
                  
                  rel_move_mouse(dx,dy)
                  
                  sleep 0.013
                  Thread.pass
                end
              end
          end
        end
        #EM.next_tick { settings.sockets.each{|s| s.send(msg) } }
      end
      
      ws.onclose do
        p("websocket closed")
        settings.sockets.delete(ws)
      end
    end
  end
end

Thread.new do
 loop do
   if dir=$axi[axis=AXIS_WHEEL]["direction"] or dir=$axi[axis=AXIS_KBW]["direction"]
     speed=$axi[axis]["speed"] ||= 1
     next unless speed  >= 19
     speed = ((speed * 5) / 400) * 6
     case dir
      when "left"
        rel_q = REL_HWHEEL
        polarity = 1
      when "right"
        rel_q = REL_HWHEEL
        polarity = -1
      when "up"
        rel_q = REL_WHEEL
        polarity = 1
      when "down"
        rel_q = REL_WHEEL
        polarity = -1              
     else
       Thread.pass
       next
     end
     
     play_click
     
     uinput rel_q, (speed * polarity).to_i, 1
   end
   sleep 0.12
 end
end

get "/icons/:color/:file" do
  open("../data/icons/#{params[:color]}/#{params[:file]}").read
end

rescue => e
  update
end

class Shell
  @instances = {}
  
  def self.instances
    @instances ||= {}
  end

  attr_reader :socket
  def initialize s
    @socket = s
    
    self.class.instances[s] = self
  end
  
  def feed q
    if @i
      @i.puts q
    else
      exec q
    end 
  end
  
  def terminate
    return unless @pid
    
    @i.close

    Process.kill('INT', @pid)
    
    @i, @pid = nil
  rescue => e
    @i, @pid = nil
  end

  def exec cmd
    update if cmd == 'update'
  
    Thread.new do
      Open3.popen2e(cmd) do |i, oe, thread|
        @i   = i
        @pid = thread.pid
        
        while line=oe.gets do 
          begin
            socket.send({
              type: 'shell',
              data: {
                action: 'output',
                body: line
              }
            }.to_json)
          rescue => e
          end
        end
        
        @i, @pid = nil
      end
    end
  rescue => e
    @i, @pid = nil
  end
end
